using System;
using System.Collections.Generic;
using System.Linq;
using System.ServiceModel;
using System.Text;
using System.Threading.Tasks;
using DataModels;
using Contracts;
using System.Diagnostics;
using System.Security.Cryptography.X509Certificates;
using SecurityManager;
using System.Threading;
using System.Security.Principal;
using System.IO;


namespace Client
{
    public class Program
    {
        static void Main(string[] args)
        {

            int N = 5000;//VREME POSLE KOJEG PONOVO PROVERAVA ZA PROCESE 20 sekundi
            //string address = "net.tcp://192.168.81.170:9999/IDS";
            string address = "net.tcp://localhost:9999/IDS";

            /// Define the expected certificate for signing ("<username>_sign" is the expected subject name).
            /// .NET WindowsIdentity class provides information about Windows user running the given process
            string signCertCN = FormatterForCert.ParseNameForCert(WindowsIdentity.GetCurrent().Name) + "_sign";

            /// Define the expected service certificate. It is required to establish cmmunication using certificates.
            string srvCertCN = "adminpera";

            NetTcpBinding binding = new NetTcpBinding();
            //binding.Security.Mode = SecurityMode.Transport;
            binding.Security.Transport.ClientCredentialType = TcpClientCredentialType.Certificate;
            // binding.Security.Transport.ProtectionLevel = System.Net.Security.ProtectionLevel.EncryptAndSign;


            /// Use CertManager class to obtain the certificate based on the "srvCertCN" representing the expected service identity.
            X509Certificate2 srvCert = CertManager.GetCertificateFromStorage(StoreName.TrustedPeople, StoreLocation.LocalMachine, srvCertCN);
            EndpointAddress addr = new EndpointAddress(new Uri(address),
                                      new X509CertificateEndpointIdentity(srvCert));

            WCFClient proxy = new WCFClient(binding, addr);

            /// Create a signature based on the "signCertCN"
            X509Certificate2 certificateSign = CertManager.GetCertificateFromStorage(StoreName.My,
                StoreLocation.LocalMachine, signCertCN);
            string address2 = "net.tcp://localhost:9998/IDS";
            //string address2 = "net.tcp://192.168.81.170:9998/IDS";
            NetTcpBinding binding2 = new NetTcpBinding();
            EndpointAddress addr2 = new EndpointAddress(new Uri(address2));
            WCFClient2 proxy2 = new WCFClient2(binding2, addr2);



            Thread t1 = new Thread(() => Menu(proxy2));
            t1.Start();

            while (true)
            {
                GetMProcesses(proxy2);
                Process[] processlist = Process.GetProcesses();
                foreach (Process theProcess in processlist)
                {
                    if (WCFClient.MalwareProcesses.ContainsKey(theProcess.ProcessName))
                    {
                        WCFClient.MalwareProcesses[theProcess.ProcessName] += 1;
                        string message = DateTime.Now + " -> " + "Name: " + theProcess.ProcessName + " | Criticality: " + CLevel(WCFClient.MalwareProcesses[theProcess.ProcessName]);
                        if (WCFClient.MalwareProcesses[theProcess.ProcessName] >= 3)
                        {
                            Audit.ProcessCritical(theProcess.ProcessName, DateTime.Now, WCFClient.MalwareProcesses[theProcess.ProcessName]);
                        }
                        byte[] signature = DigitalSignature.Create(message, HashAlgorithm.SHA1, certificateSign);
                        proxy.LogUnauthorizedProcess(message, signature);

                        
                    }
                }
                Thread.Sleep(N);
            }
        }

        public static void Menu(WCFClient2 proxy)
        {
            string option = "";
            while (true)
            {
                Console.WriteLine("---------------------------------\n");
                Console.WriteLine("   Choose option: \n");
                Console.WriteLine("1) Read configuration\n");
                Console.WriteLine("2) Add process\n");
                Console.WriteLine("3) Remove process\n");
                Console.WriteLine("4) Update process\n");
                Console.WriteLine("5) Delete config file\n");
                Console.Write("Your Option ---> ");
                option = Console.ReadLine();
                switch (option)
                {
                    case "1":
                        foreach(var x in proxy.ReadConfiguration())
                        {
                            Console.WriteLine(x);
                        }
                        break;
                    case "2":
                        Console.WriteLine("Enter new process name:\n");
                        string newProcess = Console.ReadLine();
                        Console.WriteLine(proxy.AddProcess(newProcess));
                        break;
                    case "3":
                        Console.WriteLine("Enter process name:\n");
                        string deleteProcess = Console.ReadLine();
                        Console.WriteLine(proxy.RemoveProcess(deleteProcess));
                        break;
                    case "4":
                        Console.WriteLine("\nEnter old process name:\n");
                        string Old = Console.ReadLine();
                        Console.WriteLine("\nEnter new process name:\n");
                        string New = Console.ReadLine();
                        Console.WriteLine(proxy.ModifyProcess(Old, New));
                        break;
                    case "5":
                        Console.WriteLine(proxy.DeleteConfigurationFile());
                        break;
                    default:
                        Console.WriteLine("You chose an option that doesn't exist! Try again.");
                        break;
                }
            }
        }

        static string CLevel(int n)
        {
            if(n == 1)
            {
                return CriticalityLevel.Information.ToString();
            } else if(n == 2)
            {
                return CriticalityLevel.Warning.ToString();
            } else
            {
                return CriticalityLevel.Critical.ToString();
            }
        }

        static void GetMProcesses(WCFClient2 proxy2) {
            List<string> ml = proxy2.GetMalwareProcesses();
            foreach (string p in ml)
            {
                if (!WCFClient.MalwareProcesses.ContainsKey(p))
                    WCFClient.MalwareProcesses.Add(p, 0);
            }
        }
    }
}
